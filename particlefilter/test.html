<html><head><title>Soemthing</title>
<!-- include before jQuery to make sure it's not depending on it -->
<script>
//dummy console.log if necessary
if(typeof console === "undefined") {
    console = { log: function() { } };
}
</script>
<script src="sample.js"></script>
<script src="drawmap.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
<script>
function findbot(map) {
    for (var i=0; i < map.length; i++) {
        for (var j=0; j < map[0].length; j++) {
            if (map[i][j] == "o") {
                return [i,j];
            }
        }
    }
}

function getmove(direction) {
    var move = Math.random();
    var moves = {
        "up": ["left", "right"],
        "left": ["up", "down"],
        "down": ["right", "left"],
        "right": ["down", "up"]
    }

    //80% chance bot moves where you want. Otherwise, you fail by 90 degrees
    if (move > .8) {
        direction = moves[direction][move > .9 ? 0 : 1];
    }

    return direction;
}

function movebot(map, direction) {
    var move = getmove(direction)

    var cols   = map.length;
    var rows   = map[0].length;
    var botloc = findbot(map);
    var botrow = botloc[0];
    var botcol = botloc[1];

    console.log("moving bot: " + direction);

    if (move == "up") {
        if (botrow != 0 && map[botrow-1][botcol] == '_') {
            map[botrow-1][botcol] = 'o';
            map[botrow][botcol]   = '_';
        }
    }
    else if (move == "left") {
        if (botcol != 0 && map[botrow][botcol-1] == '_') {
            map[botrow][botcol-1] = 'o';
            map[botrow][botcol]   = '_';
        }
    }
    if (move == "down") {
        if (botrow != rows.length-1 && map[botrow+1][botcol] == '_') {
            map[botrow+1][botcol] = 'o';
            map[botrow][botcol]   = '_';
        }
    }
    else if (move == "right") {
        if (botcol != cols.length-1 && map[botrow][botcol+1] == '_') {
            map[botrow][botcol+1] = 'o';
            map[botrow][botcol]   = '_';
        }
    }

    //our bot can sense if there is a wall to the north, south, east or west
    var measurement = sense(map, botloc);

    particles = particlefilter(map, particles, direction, measurement);

    return map;
}

function sense(map, botloc) {
    var row = botloc[0];
    var col = botloc[1];
    var nrows = map.length - 1; //0-indexed
    var ncols = map[0].length - 1; //0-indexed

    //an array of 4 integers. 1 represents a wall, 0 represents no wall.
    //ordered north, west, south, east.
    var measurements = [];

    var failn = Math.random();
    var failw = Math.random();
    var fails = Math.random();
    var faile = Math.random();

    //There is a 10% chance that each measurement returns a random value, so a 95%
    //chance that the measurement returns the correct measurement
    if (failn < .1) {
        measurements.push(Math.floor(failn*100) % 2);
    } else {
        measurements.push(row == 0     || map[row-1][col] == 'X' ? 1 : 0)
    }
    if (failw < .1) {
        measurements.push(Math.floor(failn*100) % 2);
    } else {
        measurements.push(col == 0     || map[row][col-1] == 'X' ? 1 : 0)
    }
    if (fails < .1) {
        measurements.push(Math.floor(failn*100) % 2);
    } else {
        measurements.push(row >= nrows || map[row+1][col] == 'X' ? 1 : 0)
    }
    if (faile < .1) {
        measurements.push(Math.floor(failn*100) % 2);
    } else {
        measurements.push(col >= ncols || map[row][col+1] == 'X' ? 1 : 0)
    }

    return measurements
}

function moveparticle(map, particle, direction) {
    var row = particle[0];
    var col = particle[1];
    var nrows = map.length;
    var ncols = map[0].length;

    var move = getmove(direction);

    if (move == "up") {
        if (row != 0 && map[row-1][col] == '_') {
            return [row-1, col];
        }
        return [row, col];
    }
    else if (move == "left") {
        if (col != 0 && map[row][col-1] == '_') {
            return [row, col-1];
        }
        return [row, col];
    }
    if (move == "down") {
        if (row < nrows-1 && map[row+1][col] == '_') {
            return [row+1, col];
        }
        return [row, col];
    }
    else if (move == "right") {
        if (col < ncols-1 && map[row][col+1] == '_') {
            return [row, col+1];
        }
        return [row, col];
    }

    throw "we should never get here: <" + move + ">";
}

function find_walls(map, row, col) {
    var walls = [];
    var nrows = map.length - 1; //0-indexed
    var ncols = map[0].length - 1; //0-indexed

    walls.push(row > 0     && map[row-1][col] != 'X' ? 0 : 1);
    walls.push(col > 0     && map[row][col-1] != 'X' ? 0 : 1);
    walls.push(row < nrows && map[row+1][col] != 'X' ? 0 : 1);
    walls.push(col < ncols && map[row][col+1] != 'X' ? 0 : 1);

    return walls;
}

//Given the particle, return the likelihood of the given measurement
function newweight(map, particle, measurement) {
    var row = particle[0];
    var col = particle[1];

    //P(wall measurement|wall) = .95
    var p_wallm_wall = .95;
    //P(wall measurement|no wall) = .05
    var p_wallm_nowall = .05;

    var probabilities = [];

    var walls = find_walls(map, row, col);

    //if we measured wall
    if (measurement[0] == 1) {
        //push P(wall measurement|wall) if it is a wall, its complement otherwise
        probabilities.push(walls[0] == 1 ? p_wallm_wall : 1-p_wallm_wall);
    } else {
        //push P(wall measurement|no wall) if it is a wall, its complement otherwise
        probabilities.push(walls[0] == 1 ? p_wallm_nowall : 1-p_wallm_nowall);
    }
    if (measurement[1] == 1) {
        probabilities.push(walls[1] == 1 ? p_wallm_wall : 1-p_wallm_wall);
    } else {
        probabilities.push(walls[1] == 1 ? p_wallm_nowall : 1-p_wallm_nowall);
    }
    if (measurement[2] == 1) {
        probabilities.push(walls[2] == 1 ? p_wallm_wall : 1-p_wallm_wall);
    } else {
        probabilities.push(walls[2] == 1 ? p_wallm_nowall : 1-p_wallm_nowall);
    }
    if (measurement[3] == 1) {
        probabilities.push(walls[3] == 1 ? p_wallm_wall : 1-p_wallm_wall);
    } else {
        probabilities.push(walls[3] == 1 ? p_wallm_nowall : 1-p_wallm_nowall);
    }

    //return the product; the probabilities are all conditionally independent.
    return probabilities.reduce(function(a,b) { return a*b });
}

function particlefilter(map, particles, control, measurement) {
    //particles, weights
    var newparticles = [[], []]
    var eta = 0;

    for (var i=0; i < particles[0].length; i++) {
        var j = weighted_sample(particles[1], particles[0]);

        var xp = moveparticle(map, j, control);
        var wp = newweight(map, xp, measurement);

        eta += wp;

        newparticles[0].push(xp);
        newparticles[1].push(wp);
    }

    //normalize our weights
    for (var i=0; i < newparticles[1].length; i++) {
        newparticles[1][i] = newparticles[1][i] / eta;
    }

    return newparticles;
}

//turn a map from a string into an array
function arraymap(maps) {
    var maplines = maps.split("\n");
    var map = [];

    for (var i=0; i < maplines.length; i++) {
        map.push(maplines[i].split(""));
    }

    return map;
}

function makeparticles(map, n) {
    var particles = [];
    var weights = [];
    var x = 0;
    var y = 0;

    for (var i=0; i < n; i++) {
        row = Math.floor(Math.random() * map.length);
        col = Math.floor(Math.random() * map[0].length);
        while (map[row][col] != "_" && map[row][col] != 'o') {
            row = Math.floor(Math.random() * map.length);
            col = Math.floor(Math.random() * map[0].length);
        }
        particles.push([row, col]);
        weights.push(1/n);
    }

    return [particles, weights];
}

function onKeyDown(evt) {
    var newmap = [];

    console.log(evt.keyCode);
    if      (evt.keyCode == 37) { newmap = movebot(map, "left"); }
    else if (evt.keyCode == 38) { newmap = movebot(map, "up"); }
    else if (evt.keyCode == 39) { newmap = movebot(map, "right"); }
    else if (evt.keyCode == 40) { newmap = movebot(map, "down"); }
    
    //only draw the map if we've executed movebot
    if (newmap.length > 0) {
        drawmap(ctx, newmap, particles[0]);
        return false;
    }
}

$(document).keydown(onKeyDown);

//Underscores are open spaces, the o is the robot, and the Xs are impassible squares.
var map = "___o__\n"
        + "_XX_X_\n"
        + "______";

var ctx;

var particles;

//make sure to use window.load so we wait for image assets to load first
$(window).load(function() {
    //get a reference to the canvas
    ctx = $('#themaze')[0].getContext("2d");

    map = arraymap(map);

    particles = makeparticles(map, 20);

    drawmap(ctx, map, particles[0]);
});
</script>
<style>
#canvas {
    height: 600px;
    width: 600px;
}
</style>
</head><body>
<img id="robotimg" src="robot.png" style="display:none">
<div id="canvas">
    <canvas id="themaze" width="600" height="600"></canvas>
</div>
</body>
</html>
